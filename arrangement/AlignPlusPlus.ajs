// Align a set of selected elements (left, top, right or bottom)

// This doesn't require objects to be part of the same layer, they could be nested within different containers

/**
 * @typedef {any} JavaClass
 * @typedef {Object<string, function>} JavaObject
 */
"use strict"

if (typeof Java == null) {
  /**
   * @type {{type: (s: string) => JavaClass, extend: (c: JavaClass) => JavaClass, super: (o: JavaObject) => JavaObject }}
   */
  var Java
  var shell
}


/** @type JavaClass */ const SWT = Java.type('org.eclipse.swt.SWT')
/** @type JavaClass */ const LabelWidget = Java.type('org.eclipse.swt.widgets.Label')
/** @type JavaClass */ const CompositeWidget = Java.type('org.eclipse.swt.widgets.Composite')
/** @type JavaClass */ const SpinnerWidget = Java.type('org.eclipse.swt.widgets.Spinner')
/** @type JavaClass */ const GroupWidget = Java.type('org.eclipse.swt.widgets.Group')
/** @type JavaClass */ const ButtonWidget = Java.type('org.eclipse.swt.widgets.Button')
/** @type JavaClass */ const GridData = Java.type('org.eclipse.swt.layout.GridData')
/** @type JavaClass */ const RowData = Java.type('org.eclipse.swt.layout.RowData')
/** @type JavaClass */ const GridLayout = Java.type('org.eclipse.swt.layout.GridLayout')
/** @type JavaClass */ const GridDataFactory = Java.type('org.eclipse.jface.layout.GridDataFactory')
/** @type JavaClass */ const GridLayoutFactory = Java.type('org.eclipse.jface.layout.GridLayoutFactory')
/** @type JavaClass */ const RowLayoutFactory = Java.type('org.eclipse.jface.layout.RowLayoutFactory')
/** @type JavaClass */ const RowLayout = Java.type('org.eclipse.swt.layout.RowLayout')
/** @type JavaClass */ const IMessageProvider = Java.type('org.eclipse.jface.dialogs.IMessageProvider')
/** @type JavaClass */ const TitleAreaDialog = Java.type("org.eclipse.jface.dialogs.TitleAreaDialog")

const ConfigDialog = Java.extend(TitleAreaDialog)

let cfgDialog = {

  /**
   * Default values
   */
  config: {
    alignmentTypes: ["top", "left", "bottom", "right"],
    alignmentType: "auto"
  },

  // widgets memorized to get value from before closing
  widgets: {},

  /**
   * Helper to create a widget
   *
   * @param {string} name - The widget name
   * @param {JavaClass} widgetClass - the Java widget class
   * @param {JavaObject} c - The container
   * @param {string} label - the label if any for the widget. A Label widget will be created if necessary
   * @param {(...a: any) => void} init - a function to finalize initialisation (value, etc )
   */
  createWidget: function (name, widgetClass, c, label, init, flags = SWT.BORDER) {
    if (label != null) {
      let txt = new LabelWidget(c, SWT.NONE)
      txt.setText(label)
      GridDataFactory.fillDefaults().align(SWT.END, SWT.CENTER).applyTo(txt)
    }
    let widget = new widgetClass(c, flags)
    if (init != null) init(widget)
    // saving in widgets reference array
    if (name != null) this.widgets[name] = widget
  },

  /**
   * as open() will destroy the widgets on close, saving values to config
   */
  saveInput: function () {

    /** no simpler way to get the selected radio button in a group :-(
     * @param {JavaObject} g - a group control
     * @returns - the selected radio button text
     */
    function getRadioGroupSelectedValue(g) {
      for (let r of g.getChildren()) {
        if (r.getSelection()) {
          return r.getText()
        }
      }
    }

    this.config.alignmentType = getRadioGroupSelectedValue(this.widgets.alignmentTypes)
  },


  open: function() {
    return (this.dialog.open() == 0)  // OK = 0, Cancel = 1, Closed = -1
  },

  // NB: Nashorn specific JS syntax! (like java anonymous function)
  // also not possible to define anything else than inherited method to override. No new method, no property
  dialog: new ConfigDialog(shell) {

    create: function () {
      Java.super(cfgDialog.dialog).create()
      cfgDialog.dialog.setTitle("Alignment settings")
    },

    createDialogArea: function (parent) {
      var cfg = cfgDialog.config
      let area = Java.super(cfgDialog.dialog).createDialogArea(parent)
      // the area contains an horizontal sep, and a grid layout
      let container = new CompositeWidget(area, SWT.NONE)
      GridDataFactory.swtDefaults().align(SWT.FILL, SWT.BEGINNING).applyTo(container)
      GridLayoutFactory.swtDefaults().numColumns(4).margins(10,10).spacing(10, 5).applyTo(container)

      // layout options
      let group = new GroupWidget(container, SWT.NONE)
      GridDataFactory.swtDefaults().span(4,1).grab(true, false).align(SWT.FILL, SWT.FILL).applyTo(group)
      group.setText('Alignment options')
      group.setLayout(new RowLayout (SWT.VERTICAL))
      cfgDialog.widgets.alignmentTypes = group
      for (let x of cfg.alignmentTypes) {
        cfgDialog.createWidget(null, ButtonWidget, group, null,
                               (w) => {
                                 w.setText(x)
                                 let wh = w.computeSize(100, SWT.DEFAULT).y
                                 w.setLayoutData(new RowData(100, wh))
                               }, SWT.RADIO)
      }
      group.getChildren()[0].setSelection(true)
      return area
    },

    okPressed: function() {
      cfgDialog.saveInput()
      Java.super(cfgDialog.dialog).okPressed()
    }
  }
}

function alignElements(alignmentType) {
  let minStartingX = Number.MAX_SAFE_INTEGER
  let minStartingY = Number.MAX_SAFE_INTEGER
  let maxEndingX   = Number.MIN_SAFE_INTEGER
  let maxEndingY   = Number.MIN_SAFE_INTEGER

  // Determine the width, height,  and
  $(selection).each(function(element) {
    if (alignmentType == "left") {
      minStartingX = Math.min(minStartingX, element.bounds.x)
    } else if (alignmentType == "top") {
      minStartingY = Math.min(minStartingY, element.bounds.y)
    } else if (alignmentType == "right") {
      maxEndingX = Math.max(maxEndingX, element.bounds.x + element.bounds.width)
    } else {
      maxEndingY = Math.max(maxEndingY, element.bounds.y + element.bounds.height)
    }
  })

  // Sort the selection so the order stays the same
  $(selection).sort(function (left,right) {
    return left.bounds.x-right.bounds.x
  })

  // Walk throught the sorted selection
  $(selection).each(function (element) {
    let newBounds = { x: element.x, y: element.y, width: element.width, height: element.height }

    if (alignmentType == "left") {
      newBounds.x = minStartingX
    } else if (alignmentType == "top") {
      newBounds.y = minStartingY
    } else if (alignmentType == "right") {
      newBounds.x = maxEndingX - newBounds.width
    } else {
      newBounds.y = maxEndingY - newBounds.height
    }

    element.bounds = newBounds
  })

}

// Test
console.clear()
console.show()

console.log("START> AlignPlusPlus.")
if (cfgDialog.open()) {
  console.log("Aligning", $(selection).length, "elements (", cfgDialog.config.alignmentType, "alignment ).")
  alignElements(cfgDialog.config.alignmentType)
}
console.log("END> AlignPlusPlus.")


